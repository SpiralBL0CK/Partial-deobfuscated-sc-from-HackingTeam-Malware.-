package o;

import org.json.JSONObject;

public final class ParserHelper
  extends Document
{
  private int count;
  private int index;
  private int pos;
  private boolean s = false;
  private int type;
  
  public ParserHelper() {}
  
  public final void doInBackground()
  {
    s = false;
  }
  
  public final void execute()
  {
    parse();
  }
  
  public final boolean execute(Track paramTrack)
  {
    JSONObject localJSONObject = this$0;
    try
    {
      boolean bool = localJSONObject.has("country");
      int i;
      if (bool == true)
      {
        i = paramTrack.getInt("country");
        index = i;
      }
      else
      {
        index = -1;
      }
      localJSONObject = this$0;
      bool = localJSONObject.has("network");
      if (bool == true)
      {
        i = paramTrack.getInt("network");
        pos = i;
      }
      else
      {
        pos = -1;
      }
      localJSONObject = this$0;
      bool = localJSONObject.has("area");
      if (bool == true)
      {
        i = paramTrack.getInt("area");
        count = i;
      }
      else
      {
        count = -1;
      }
      localJSONObject = this$0;
      bool = localJSONObject.has("id");
      if (bool == true)
      {
        i = paramTrack.getInt("id");
        type = i;
      }
      else
      {
        type = -1;
      }
      value = 60000L;
      set();
      count = 1000L;
      set();
    }
    catch (JSONException paramTrack)
    {
      for (;;) {}
    }
    return false;
    return true;
  }
  
  public final void read()
  {
    Location localLocation = Util.update();
    if (!index) {
      return;
    }
    if (((index == -1) || (index == value)) && ((pos == -1) || (pos == length)) && ((count == -1) || (count == flags)) && ((type == -1) || (type == type)))
    {
      if (!s)
      {
        s = true;
        init();
      }
    }
    else if (s)
    {
      s = false;
      parse();
    }
  }
}
