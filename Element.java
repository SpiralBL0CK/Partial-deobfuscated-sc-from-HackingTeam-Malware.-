package o;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.ByteBuffer;

public final class Element
{
  private static byte id;
  private static boolean value;
  private String path = "core";
  private final FieldInfo this$0;
  
  private Element()
  {
    this$0 = new FieldInfo(JSONObject.get().getInt());
  }
  
  public Element(Class paramClass)
  {
    this$0 = new FieldInfo("978FA690C2FA64B5".getBytes());
    path = "BSm";
  }
  
  public Element(Integer paramInteger)
  {
    this();
  }
  
  private Element(String paramString)
  {
    this();
  }
  
  private Element(String paramString, int paramInt)
  {
    this();
  }
  
  public Element(Call paramCall, int paramInt)
  {
    this("MOD" + Context.get().get(paramCall.getClass()), paramInt);
  }
  
  public Element(Document paramDocument)
  {
    this("EVT" + paramDocument.getName(), paramDocument.getId());
  }
  
  public Element(Model paramModel)
  {
    this("AGN" + Context.get().get(paramModel.getClass()));
  }
  
  public Element(Template paramTemplate, String paramString)
  {
    this("MOD" + paramTemplate.getClass() + "_" + paramString);
  }
  
  public static int doInBackground()
  {
    int j = 0;
    try
    {
      String[] arrayOfString = Filenamelengthfile.list();
      int k = arrayOfString.length;
      int i = 0;
      while (i < k)
      {
        String str = arrayOfString[i];
        Filenamelengthfile.delete();
        j += 1;
        i += 1;
      }
      return j;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  private static String toString(String paramString)
  {
    paramString = paramString.getBytes();
    paramString = Files.encode(paramString, paramString.length);
    paramString = Method.toString(paramString, paramString.length);
    Object localObject = Logger.name + Logger.length;
    localObject = new StringBuilder().append((String)localObject);
    paramString = paramString + ".mm";
    if (!value)
    {
      id = "7EE76748FB3A49F6".getBytes()[0];
      value = true;
    }
    return FieldInfo.getAttribute(paramString, id);
  }
  
  public final boolean append(Serializable paramSerializable)
  {
    try
    {
      ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream();
      new ObjectOutputStream(localByteArrayOutputStream).writeObject(paramSerializable);
      boolean bool = write(localByteArrayOutputStream.toByteArray());
      return bool;
    }
    catch (Throwable paramSerializable)
    {
      throw paramSerializable;
    }
  }
  
  public final void clear()
  {
    try
    {
      FiletoStringpath)).file.delete();
      return;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public final byte[] getName()
  {
    for (;;)
    {
      try
      {
        localObject = new File(toString(path));
        if (file.exists())
        {
          localObject = ((File)localObject).next(0);
          i = Method.get((byte[])localObject, 0);
          localFieldInfo = this$0;
        }
      }
      catch (Throwable localThrowable)
      {
        Object localObject;
        int i;
        FieldInfo localFieldInfo;
        throw localThrowable;
      }
      try
      {
        localObject = localFieldInfo.update((byte[])localObject, i);
      }
      catch (ActivatingIterator localActivatingIterator) {}
    }
    return null;
    return localObject;
    return null;
  }
  
  public final Object read()
  {
    try
    {
      localObject = new ObjectInputStream(new ByteArrayInputStream(getName()));
    }
    catch (Throwable localThrowable)
    {
      Object localObject;
      label32:
      throw localThrowable;
    }
    try
    {
      localObject = ((ObjectInput)localObject).readObject();
      return localObject;
    }
    catch (ClassNotFoundException localClassNotFoundException)
    {
      break label32;
    }
    throw new IOException();
  }
  
  public final Serializable toString(Serializable paramSerializable)
  {
    Object localObject = paramSerializable;
    if (write()) {}
    try
    {
      localObject = read();
      localObject = (Serializable)localObject;
      return localObject;
    }
    catch (IOException localIOException) {}
    return paramSerializable;
  }
  
  public final boolean write()
  {
    try
    {
      boolean bool = FiletoStringpath)).file.exists();
      return bool;
    }
    catch (Throwable localThrowable)
    {
      throw localThrowable;
    }
  }
  
  public final boolean write(byte[] paramArrayOfByte)
  {
    try
    {
      File localFile = new File(toString(path));
      localFile.write(new byte[] { 0 }, false);
      if (paramArrayOfByte != null)
      {
        byte[] arrayOfByte = this$0.update(paramArrayOfByte);
        int i = paramArrayOfByte.length;
        paramArrayOfByte = new byte[4];
        System04this$0.putInt(i);
        localFile.write(paramArrayOfByte, false);
        localFile.write(arrayOfByte, true);
      }
      boolean bool = file.exists();
      return bool;
    }
    catch (Throwable paramArrayOfByte)
    {
      throw paramArrayOfByte;
    }
  }
}
