package o;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.zip.CRC32;

public class Node
  extends ?
  implements ?<?>
{
  public static HashMap<Long, Long> index;
  private Track.1 attributes;
  private String file;
  public Element next;
  
  public Node() {}
  
  public static void add(int paramInt, String paramString1, String paramString2)
  {
    ByteArrayOutputStream localByteArrayOutputStream = parse(-paramInt, paramInt, java.lang.Integer.MIN_VALUE);
    if (localByteArrayOutputStream == null) {
      return;
    }
    write(localByteArrayOutputStream, (byte)64, paramString1);
    if (paramString2 != null) {
      write(localByteArrayOutputStream, (byte)1, paramString2);
    }
    paramString1 = localByteArrayOutputStream.toByteArray();
    paramInt = localByteArrayOutputStream.size();
    System04this$0.putInt(paramInt);
    paramString1 = new Field(512, null, paramString1);
    paramString2 = getthis$0;
    try
    {
      paramString2.put(paramString1);
      return;
    }
    catch (Exception paramString1) {}
  }
  
  public static boolean add(int paramInt, BoundingBox paramBoundingBox)
  {
    long l = paramBoundingBox.set();
    paramBoundingBox = get(paramInt, l, name, type, width);
    boolean bool = get(l, paramBoundingBox);
    if (bool)
    {
      paramBoundingBox = new Field(512, null, paramBoundingBox);
      LinkedBlockingQueue localLinkedBlockingQueue = getthis$0;
      try
      {
        localLinkedBlockingQueue.put(paramBoundingBox);
        return bool;
      }
      catch (Exception paramBoundingBox) {}
    }
    return bool;
  }
  
  private static boolean get(long paramLong, byte[] paramArrayOfByte)
  {
    Long localLong = (Long)index.get(Long.valueOf(paramLong));
    CRC32 localCRC32 = new CRC32();
    localCRC32.reset();
    localCRC32.update(paramArrayOfByte);
    paramArrayOfByte = Long.valueOf(localCRC32.getValue());
    if (!paramArrayOfByte.equals(localLong))
    {
      index.put(Long.valueOf(paramLong), paramArrayOfByte);
      return true;
    }
    return false;
  }
  
  private static byte[] get(int paramInt, long paramLong, String paramString1, String paramString2, String paramString3)
  {
    ByteArrayOutputStream localByteArrayOutputStream = parse(paramLong, paramInt, 0);
    if (localByteArrayOutputStream == null) {
      return null;
    }
    write(localByteArrayOutputStream, (byte)1, paramString2);
    write(localByteArrayOutputStream, (byte)7, paramString1);
    write(localByteArrayOutputStream, (byte)55, paramString3);
    write(localByteArrayOutputStream, (byte)64, paramString1);
    paramString1 = localByteArrayOutputStream.toByteArray();
    paramInt = paramString1.length;
    System04this$0.putInt(paramInt);
    return paramString1;
  }
  
  private static ByteArrayOutputStream parse(long paramLong, int paramInt1, int paramInt2)
  {
    ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream();
    byte[] arrayOfByte = new byte[4];
    try
    {
      Object localObject = new System(arrayOfByte, 0, 4);
      localObject = this$0;
      ((ByteBuffer)localObject).putInt(0);
      localByteArrayOutputStream.write(arrayOfByte);
      arrayOfByte = new byte[4];
      localObject = new System(arrayOfByte, 0, 4);
      localObject = this$0;
      ((ByteBuffer)localObject).putInt(16777217);
      localByteArrayOutputStream.write(arrayOfByte);
      int i = (int)paramLong;
      arrayOfByte = new byte[4];
      localObject = new System(arrayOfByte, 0, 4);
      localObject = this$0;
      ((ByteBuffer)localObject).putInt(i);
      localByteArrayOutputStream.write(arrayOfByte);
      arrayOfByte = new byte[4];
      localObject = new System(arrayOfByte, 0, 4);
      localObject = this$0;
      ((ByteBuffer)localObject).putInt(paramInt1);
      localByteArrayOutputStream.write(arrayOfByte);
      arrayOfByte = new byte[4];
      localObject = new System(arrayOfByte, 0, 4);
      localObject = this$0;
      ((ByteBuffer)localObject).putInt(paramInt2);
      localByteArrayOutputStream.write(arrayOfByte);
      return localByteArrayOutputStream;
    }
    catch (IOException localIOException)
    {
      for (;;) {}
    }
    return null;
  }
  
  public static Node write()
  {
    return (Node)Context.get().remove(?.class);
  }
  
  public static void write(int paramInt, String paramString)
  {
    add(paramInt, paramString, null);
  }
  
  private static void write(ByteArrayOutputStream paramByteArrayOutputStream, byte paramByte, String paramString)
  {
    int i;
    byte[] arrayOfByte;
    if (paramString != null)
    {
      if (paramString.length() > 0)
      {
        i = paramString.length();
        arrayOfByte = new byte[4];
      }
    }
    else {
      try
      {
        Object localObject = new System(arrayOfByte, 0, 4);
        localObject = this$0;
        ((ByteBuffer)localObject).putInt(paramByte << 24 | i << 1);
        paramByteArrayOutputStream.write(arrayOfByte);
        paramByteArrayOutputStream.write(Logger.get(paramString, false));
        return;
      }
      catch (IOException paramByteArrayOutputStream) {}
    }
  }
  
  public final void doInBackground()
  {
    value = 10800000L;
    set();
    count = 200L;
    set();
    Envelope.getValue().add(this);
    next = new Element(this);
    Object localObject;
    if (next.write()) {
      localObject = next;
    }
    try
    {
      localObject = ((Element)localObject).read();
      index = (HashMap)localObject;
    }
    catch (IOException localIOException1)
    {
      for (;;)
      {
        try
        {
          HashMap localHashMap;
          ((Element)localObject).append(localHashMap);
          return;
        }
        catch (IOException localIOException2) {}
        localIOException1 = localIOException1;
      }
    }
    if (index == null)
    {
      index = new HashMap();
      localObject = next;
      localHashMap = index;
    }
  }
  
  public final void execute()
  {
    Envelope.getValue().update(this);
  }
  
  public final boolean execute(Integer paramInteger)
  {
    return true;
  }
  
  public final void read()
  {
    try
    {
      JSONArray.get();
      boolean bool1 = JSONArray.length();
      if (bool1) {
        Level.read(new AccountListFragment.1(this));
      }
      Object localObject1 = new Track.1();
      attributes = ((Track.1)localObject1);
      new Date();
      localObject1 = Track.1.doInBackground();
      new Date();
      Iterator localIterator = ((Hashtable)localObject1).values().iterator();
      bool1 = false;
      Object localObject2 = new Type(512);
      for (;;)
      {
        boolean bool2 = localIterator.hasNext();
        if (!bool2) {
          break;
        }
        localObject1 = localIterator.next();
        Waypoint localWaypoint = (Waypoint)localObject1;
        localObject1 = index;
        ArrayList localArrayList = this$0;
        l = length;
        String str1 = type;
        String str2 = localWaypoint.read();
        localObject1 = "";
        int i = localArrayList.size();
        if (i > 0)
        {
          localObject1 = localArrayList.get(0);
          localObject1 = pointer;
        }
        localObject1 = get(8, l, (String)localObject1, str1, str2);
        l = index.length;
        boolean bool3 = get(l, (byte[])localObject1);
        bool2 = bool3;
        bool1 = bool2;
        if (bool3)
        {
          ((Type)localObject2).get((byte[])localObject1);
          bool1 = bool2;
        }
      }
      long l = name;
      localObject1 = new Field(l);
      type = 5;
      ((Type)localObject2).get((Field)localObject1);
      if (bool1)
      {
        localObject1 = next;
        localObject2 = index;
      }
      return;
    }
    catch (Exception localException1)
    {
      try
      {
        ((Element)localObject1).append((Serializable)localObject2);
        return;
      }
      catch (IOException localIOException)
      {
        return;
      }
      catch (Exception localException2) {}
      localException1 = localException1;
      return;
    }
  }
}
