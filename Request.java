package o;

import java.io.File;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.concurrent.LinkedBlockingQueue;

public class Request
  extends Thread
  implements Runnable
{
  private static volatile Request data;
  public boolean finished = false;
  private File out;
  private final HashMap<Long, ?> responseHeaders = new HashMap();
  public boolean started;
  public final LinkedBlockingQueue<AUx> this$0 = new LinkedBlockingQueue(8);
  
  private Request() {}
  
  public static Request get()
  {
    if (data == null) {
      try
      {
        if (data == null) {
          data = new Request();
        }
      }
      catch (Throwable localThrowable)
      {
        throw localThrowable;
      }
    }
    return data;
  }
  
  private void process()
  {
    Object localObject1 = null;
    Object localObject2 = this$0;
    try
    {
      localObject2 = ((LinkedBlockingQueue)localObject2).take();
      localObject1 = (Field)localObject2;
    }
    catch (InterruptedException localInterruptedException)
    {
      Object localObject3;
      for (;;) {}
    }
    switch (type)
    {
    default: 
      
    case 1: 
      localObject2 = key;
      localObject3 = new Buffer(name);
      if (((Buffer)localObject3).get((byte[])localObject2))
      {
        responseHeaders.put(Long.valueOf(data), localObject3);
        return;
      }
      break;
    case 2: 
      localObject2 = key;
      localObject3 = id;
      localObject1 = new Buffer(name);
      ((Buffer)localObject1).get((byte[])localObject2);
      ((Buffer)localObject1).write((byte[])localObject3);
      ((Buffer)localObject1).write();
      return;
    case 4: 
      if (responseHeaders.containsKey(Long.valueOf(data)))
      {
        ((Buffer)responseHeaders.get(Long.valueOf(data))).write(id);
        return;
      }
      break;
    case 6: 
      localObject2 = new Buffer(name);
      Object localObject4 = content;
      ((Buffer)localObject2).get(null);
      int i = 0;
      localObject1 = ((ArrayList)localObject4).iterator();
      while (((Iterator)localObject1).hasNext()) {
        i += ((byte[])((Iterator)localObject1).next()).length;
      }
      localObject1 = new byte[i];
      localObject3 = new System((byte[])localObject1, 0, i);
      localObject4 = ((ArrayList)localObject4).iterator();
      while (((Iterator)localObject4).hasNext())
      {
        byte[] arrayOfByte = (byte[])((Iterator)localObject4).next();
        this$0.put(arrayOfByte);
      }
      ((Buffer)localObject2).write((byte[])localObject1);
      ((Buffer)localObject2).write();
      return;
    case 5: 
      if (responseHeaders.containsKey(Long.valueOf(data)))
      {
        localObject2 = (Buffer)responseHeaders.get(Long.valueOf(data));
        if (localObject2 != null) {
          ((Buffer)localObject2).write();
        }
        responseHeaders.remove(Long.valueOf(data));
        return;
      }
      break;
    case -1: 
      finished = true;
    case 0: 
    case 3: 
      
    }
  }
  
  public void run()
  {
    started = true;
    out = new File(Logger.name + Logger.value);
    out.mkdirs();
    while (!finished) {
      process();
    }
    this$0.clear();
    responseHeaders.clear();
    started = false;
  }
}
